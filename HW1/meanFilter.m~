function [ outImg ] = meanFilter(inImg, kernel_size)
    kernel = ones(kernel_size, kernel_size) * (1/9);
    imSize = size(inImg);
    rgbArr = imSize(3);
    xSize = imSize(2);
    ySize = imSize(1);
    kernel_overlap = floor(kernel_size/2);
    for rgb = 1:rgbArr
        %Loop through rgb pixels
        for col = 1:xSize
            %loop through rows
            for row = 1:ySize
                colBuff = -floor(kernel_size/2);
                rowBuff = -floor(kernel_size/2);
                convSum = 0;
                kernShadow = zeros(3,3);
                for colKern = 1:kernel_size
                    
                    for rowKern = 1:kernel_size
                        modRow = mod(row + rowBuff, ySize);
                        
                        if modRow == 0
                            modRow = 1;
                        end
                        
                        modCol = mod(col + colBuff, xSize);
                        
                        if modCol == 0
                            modCol = 1;
                        end
                        
                        [mod
                        convSum = convSum + kernel(rowKern,colKern) * inImg(modRow, modCol);
                        rowBuff = rowBuff + 1;
                        
                    end
                    colBuff = colBuff + 1;
                    
 
                end
                outImg(row,col,rgb) = convSum;
                
                %cols in inner loop for efficiency
                %{
                if col <= kernel_overlap
                    colLimit = floor(kernel_size/col/2)
                    ykernStart = 1  + colLimit
                    ykernEnd = kernel_size
                    
                elseif col >= ySize - kernel_overlap
                    colLimit = -floor(kernel_size/col/2)
                    ykernStart = 1
                    yKernEnd = kernel_size - colLimit
                    
                else
                    colLimit = 0
                    ykernStart = 1
                    ykernEnd = kernel_size
                end
                
                if row <= kernel_overlap
                    rowLimit = floor(kernel_size/row/2)
                    xkernStart = 1 + colLimit
                    xkernEnd = kernel_size
                    
                elseif row >= xSize - kernel_overlap
                    rowLimit = -floor(kernel_size/row/2)
                    xkernStart = 1
                    xkernEnd = kernel_size - rowLimit
                    
                else
                    rowLimit = 0
                    xkernStart = 1
                    xkernEnd = kernel_size
                end

                kernSum = 0
                
                if colLimit ~= 0
                    if colLimit > 0
                        %start at row,col pixel
                        colRangeS
                    end
                end
                
                if rowLimit ~= 0
                    imgXbuff = 
                end
                    
                    
                  
                for kernX = xkernStart:xkernEnd + rowLimit
                    
                    for kernY = ykernStart:ykernEnd
                        kernSum = kernSum + kernel(kernX, kernY) *   
                        
                    end
                end
                %}
                
                
                
            end
        end
    end
end
    